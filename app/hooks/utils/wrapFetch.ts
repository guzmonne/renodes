/**
 * AsyncFunction is a function that gets or creates data asynchronously.
 * @param variables - Any function variables.
 * @returns Any kind of data.
 */
export declare type AsyncFunction<TData = unknown, TVariables = unknown> = (variables: TVariables) => Promise<TData>;
/**
 * AsyncRequestFunction wraps the functionality of the ajax function.
 * @param variables - Any function variables.
 */
export declare type AsyncRequestFunction<TVariables = void> = (variables: TVariables) => void;
/**
 * AsyncOptions is the configuration interface for the ajax function.
 */
export interface AsyncOptions<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> {
  /**
   * uri points to the endpoint that must be called.
   */
  uri: string;
  /**
   * method must be a valid HTTP method.
   */
  method?: "get" | "post" | "put" | "patch" | "delete";
  /**
   * transform is an optional callback that can transform the TVariables before calling the fetch request.
   */
  transform?: (variables: TVariables) => any;
  /**
   * onRequest is an optional callback that will be called before calling the asyncFn. Whatever it returns
   * will be considered as context for the other callbacks.
   * @param variables - The same variables used on the asyncFn callback.
   * @returns The context for the other callback functions.
   */
  onRequest?: (variables: TVariables) => Promise<TContext> | Promise<undefined> | TContext | undefined;
  /**
   * onSuccess is an optional callback that will be called if the asyncFn finishes successfully.
   * @param data - The data returned by the asyncFn.
   * @param variables - The variables used to call the asyncFn.
   * @param context - Context value generated by the onRequest callback.
   */
  onSuccess?: (data: TData, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
  /**
   * onFailure is an optional callback that will be called if anything goes wrong during the
   * execution of the asyncFnRequest function.
   * @param error - Caught error.
   * @param variables - Variables used to call the asyncFn.
   * @param context - Context value generated by the onRequest callback.
   */
  onError?: (error: TError, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
}
/**
 * AsyncResult is the object returned by the ajax function.
 */
export interface AsyncResult<TData = unknown, TError = unknown, TVariables = unknown, TContext = unknown> {
  /**
   * context is generated by the onRequest function. It is then available to the onSuccess and onError callback.
   */
  context: TContext | undefined;
  /**
   * data is the value returned by the asyncFn function.
   */
  data: TData | undefined;
  /**
   * error holds the error information generated while running the asyncFnRequest function.
   */
  error: TError | null;
  /**
   * status describes the current status of the asyncFnRequest
   */
  status: "idle" | "loading" | "request" | "success" | "failure";
  /**
   * request is the actual asyncFnRequest function that must be called to execute a mutation.
   */
  request: AsyncRequestFunction<TVariables>;
  /**
   * variables hold the last variables used when running the asyncFnRequest.
   */
  variables: TVariables | undefined;
}
/**
 * wrapFetch is a function that can wrap an async action and provide callbacks that will be run
 * while executing the main mutation, and provides aditional metadata about the request, like
 * its status.
 * @param asynFn - Async function that holds the logic for a mutation.
 * @param options - Callback definition.
 */
export function wrapFetch<TData = unknown, TError = unknown, TVariables = void, TContext = unknown>(
  options: AsyncOptions<TData, TError, TVariables, TContext>
): AsyncResult<TData, TError, TVariables, TContext> {
  const result: AsyncResult<TData, TError, TVariables, TContext> = {
    context: undefined,
    data: undefined,
    variables: undefined,
    error: null,
    status: "idle",
    request: async (variables) => {
      result.variables = variables
      try {
        if (options && options.onRequest) {
          result.status = "request"
          result.context = await options.onRequest(variables)
        }
        result.status = "loading"
        const response = await fetch(options.uri, {
          method: options.method || "get",
          body: formEncode(options.transform ? options.transform(variables) : variables)
        })
        if (!response.ok) throw new Error(await response.text())
        result.data = await response.json()
        result.status = "success"
        if (options.onSuccess) await options.onSuccess(result.data, result.variables, result.context)
      } catch (err) {
        result.status = "failure"
        result.error = err
        if (options.onError) await options.onError(result.error, result.variables, result.context)
        return
      }
    },
  }
  return result
}
/**
 * Functions
 */
/**
 * formEncode converts an object into a valid form encoded string.
 * @param obj - Object to stringify.
 */
function formEncode(obj: any): string {
  const formBody = []
  for (let [key, value] of Object.entries(obj)) {
    if (value === undefined || value === null) continue
    let encodedKey = encodeURIComponent(key)
    let encodedVal = typeof value === "object" ? formEncode(value) : encodeURIComponent(value as any)
    formBody.push(encodedKey + "=" + encodedVal)
  }
  return formBody.join("&")
}